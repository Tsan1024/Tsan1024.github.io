[{"categories":["Tech"],"contents":"go Test 单元测试编写 Go 语言的单元测试默认采用官方自带的测试框架，通过引入 testing 包以及 执行 go test 命令来实现单元测试功能。\nGo 单元测试的基本规范如下：\n测试函数需导入 testing 包。测试函数的命名类似func TestName(t *testing.T)，入参是 *testing.T 测试函数的函数名须以大写的 Test 开头，后面紧跟的函数名，比如 func TestName(t *testing.T) 或者 func Test_name(t *testing.T)， 但是 func Testname(t *testing.T)不会被检测到 一般测试文件的命名，都是 {source_filename}_test.go，比如源代码文件是Add.go ，那么就会在 Add.go 的相同目录下，再建立一个 Add_test.go 的单元测试文件 go test 会遍历所有的 *_test.go 中符合上述命名规则的函数，然后生成一个临时的 main 包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n基础示例 # 原函数 package test func Add(args1, args2 int) int { result := args1 + args2 return result } # 测试代码 package test import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestAdd(t *testing.T) { value := Add(1, 2) fmt.Println(value) } # 运行所有test go test # 运行test并打印详情 go test -v # 运行具体某个方法的单元测试 # go test -v -run=\u0026#34;xxx\u0026#34; # 执行单测并计算覆盖率 go test -v -cover # 将覆盖率导入到文件 go test -cover -covermode=count -coverprofile=cover.out # covermode 代码分析模式（set：是否执行；count：执行次数；atomic：次数，并发执行） # 查看测试文件 go tool cover -func=cover.out 子测试（Subtests） func TestReduce(t *testing.T) { t.Run(\u0026#34;add\u0026#34;, func(t *testing.T) { if Reduce(2, 3) == 4 { t.Fatal(\u0026#34;fail\u0026#34;) } }) t.Run(\u0026#34;neg\u0026#34;, func(t *testing.T) { if Reduce(2, 3) != -6 { t.Fatal(\u0026#34;fail\u0026#34;) } }) } 对于多个子测试的场景，推荐表格驱动测试(table-driven tests)的写法： func TestReduce(t *testing.T) { cases := []struct { Name string A, B, Expected int }{ {\u0026#34;pos\u0026#34;, 2, 3, 6}, {\u0026#34;neg\u0026#34;, 2, -3, -6}, {\u0026#34;zero\u0026#34;, 2, 0, 0}, } for _, c := range cases { t.Run(c.Name, func(t *testing.T) { if ans := Add(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026#34;%d * %d expected %d, but %d got\u0026#34;, c.A, c.B, c.Expected, ans) } }) } } 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的优势如下：\n新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。 如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。\n帮助函数(helpers) 对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。\ntype addCase struct{ A, B, Expected int } func createAddTestCase(t *testing.T, c *addCase) { t.Helper() if ans := Add(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026#34;%d * %d expected %d, but %d got\u0026#34;, c.A, c.B, c.Expected, ans) } } func TestAdd(t *testing.T) { createAddTestCase(t, \u0026amp;addCase{4, 2, 6}) // success case createAddTestCase(t, \u0026amp;addCase{1, -3, -6}) // wrong case } 为方便定位，调用 t.Helper() 可以让报错信息更准确，直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。\nsetup 与 teardown package codetest import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) // setup 函数，在所有测试运行之前执行 func setup() { fmt.Println(\u0026#34;Setup before tests\u0026#34;) // 执行一些初始化操作 } // teardown 函数，在所有测试运行之后执行 func teardown() { fmt.Println(\u0026#34;Teardown after tests\u0026#34;) // 执行一些清理操作 } // TestMain 函数，用于自定义测试的行为 func TestMain(m *testing.M) { // 执行 setup 函数 setup() // 运行所有测试 exitCode := m.Run() // 执行 teardown 函数 teardown() // 退出测试程序 fmt.Println(\u0026#34;Exiting with code\u0026#34;, exitCode) } // 具体的测试函数 func TestSomething(t *testing.T) { // 在这里编写你的测试逻辑 fmt.Println(\u0026#34;Running TestSomething\u0026#34;) // 断言或其他测试操作 } func TestAnotherThing(t *testing.T) { // 在这里编写另一个测试逻辑 fmt.Println(\u0026#34;Running TestAnotherThing\u0026#34;) // 断言或其他测试操作 } func setupTest(tb testing.TB) func(tb testing.TB) { fmt.Printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, \u0026#34;\u0026gt;\u0026gt; Setup Test\\n\u0026#34;) return func(tb testing.TB) { fmt.Printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, \u0026#34;\u0026gt;\u0026gt; Teardown Test\\n\u0026#34;) } } func TestToString(t *testing.T) { type args struct { value interface{} } tests := []struct { name string args args want interface{} }{ { name: \u0026#34;int\u0026#34;, args: args{ value: 101, }, want: \u0026#34;100\u0026#34;, }, { name: \u0026#34;boolean\u0026#34;, args: args{ value: true, }, want: \u0026#34;true\u0026#34;, }, { name: \u0026#34;float32\u0026#34;, args: args{ value: float32(100.01), }, want: \u0026#34;100.01\u0026#34;, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { teardown := setupTest(t) defer teardown(t) if got := ToString(tt.args.value); !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;ToString() = %v, want %v\u0026#34;, got, tt.want) } }) } } // ToString convert any type to string func ToString(value interface{}) string { if v, ok := value.(*string); ok { return *v } return fmt.Sprintf(\u0026#34;%v\u0026#34;, value) } 测试网络 需要测试某个 API 接口的 handler 能够正常工作，例如 addHandler\npackage codetest // test code import ( \u0026#34;bytes\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; ) func addHandler(w http.ResponseWriter, r *http.Request) { body, _ := io.ReadAll(r.Body) w.Write([]byte(body)) } func handleError(t *testing.T, err error) { t.Helper() if err != nil { t.Fatal(\u0026#34;failed\u0026#34;, err) } } func TestConn(t *testing.T) { ln, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:0\u0026#34;) handleError(t, err) defer ln.Close() payload := []byte(`{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}`) // 创建一个字节缓冲区，并将数据写入其中 reqBody := bytes.NewBuffer(payload) http.HandleFunc(\u0026#34;/add\u0026#34;, addHandler) go http.Serve(ln, nil) resp, err := http.Post(\u0026#34;http://\u0026#34;+ln.Addr().String()+\u0026#34;/add\u0026#34;, \u0026#34;application/json\u0026#34;, reqBody) handleError(t, err) defer resp.Body.Close() body, err := io.ReadAll(resp.Body) handleError(t, err) if string(body) != \u0026#34;add\u0026#34; { t.Fatal(\u0026#34;expected add, but got\u0026#34;, string(body)) } } 针对 http 开发的场景，更推荐使用标准库 net/http/httptest 进行测试。使用 httptest 模拟请求对象(req)和响应对象(w)，将TestConn替换成如下:\nfunc TestConn(t *testing.T) { req := httptest.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://example.com/add\u0026#34;, nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != \u0026#34;add\u0026#34; { t.Fatal(\u0026#34;expected add, but got\u0026#34;, string(bytes)) } } Benchmark 基准测试 基准测试用例的定义如下：\nfunc BenchmarkName(b *testing.B){ // ... } 函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。\n执行如下：\ngo test -benchmem -bench . 以下参考极客兔兔，基准测试报告每一列值对应的含义如下：\ntype BenchmarkResult struct { N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 } 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：\nfunc BenchmarkHello(b *testing.B) { ... // 耗时操作, 如 big := NewBig() b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026#34;hello\u0026#34;) } } 使用 RunParallel 测试并发性能\nfunc BenchmarkParallel(b *testing.B) { templ := template.Must(template.New(\u0026#34;test\u0026#34;).Parse(\u0026#34;Hello, {{.}}!\u0026#34;)) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(\u0026amp;buf, \u0026#34;World\u0026#34;) } }) } 执行\ngo test -benchmem -bench . 参考连接： https://juejin.cn/post/7172037988950474759 https://brantou.github.io/2017/05/24/go-cover-story/ https://ruichengm1987.github.io/docs/go/ https://pkg.go.dev/testing ","date":"2023-12-26T23:17:45+08:00","permalink":"https://tsan1024.github.io/post/tech/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/","section":"post","tags":["golang","test"],"title":"golang 单元测试"},{"categories":["Tech"],"contents":"c++编程规范： https://zh-google-styleguide.readthedocs.io/en/latest/contents/\n","date":"2023-12-08T23:01:12+08:00","permalink":"https://tsan1024.github.io/post/tech/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","section":"post","tags":["c++"],"title":"编程规范"},{"categories":["robots"],"contents":"ROS2通信模型 话题 服务 参数 动作 参考链接 入门教程：https://book.guyuehome.com/ ROS 和 ROS2 架构和通信 https://codeantenna.com/a/909CWGyaSo#5_ROS_2__131 ","date":"2023-12-03T21:02:15+08:00","permalink":"https://tsan1024.github.io/post/robots/ros%E9%80%9A%E4%BF%A1/","section":"post","tags":["ros2","ros"],"title":"ROS架构与通信"},{"categories":["Robots"],"contents":"机器人学导论 \u003c!DOCTYPE HTML\u003e 参考链接： Hugo 通过 ShortCodes 添加视频\n","date":"2023-11-28T23:42:23+08:00","permalink":"https://tsan1024.github.io/post/robots/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91/","section":"post","tags":["robots"],"title":"机器人导学教学视频"},{"categories":["Tech"],"contents":"k8s 架构 MasterNode包含3个程序，分别是： ApiServer： 提供HTTP Rest接口，是集群中各种核心资源的CRUD的统一入口，是集群中各个组件交互的核心枢纽 集群资源配额的统一入口 提供了完备的集群安全机制 ControllerManager： 实时监控集群中如Service等各种资源的状态变化，不断尝试将它们的副本数量维持在一个期望的状态。 Scheduler： 负责调度功能，如：为Pod找到一个合适的宿主机器 WorkerNode包含两个组件， 分别是： kubelet Node节点管理 Pod管理，同容器运行时交互下发容器的创建/关闭命令 容器健康状态检查 kube-proxy 通过为Service资源的ClusterIP生成iptable或ipvs规则，实现将K8S内部的服务暴露到集群外面去 概念 Pod Pod 是一组紧密关联的容器集合，它们共享 IPC 和 Network namespace，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod的实现基于共享网络和共享存储：\n共享网络：共享IP、Ports及MAC地址\n在POD的初始化中，会首先建立1个叫做Pause或info根容器。在这个根容器中，会被分配1个ip地址，mac地址和 ports端口。POD会继续根据要求创造若干个应用容器，每个应用容器都会作为子容器加入到根容器中，这些子容器就可以共享根容器的网络资源。 共享网络 共享存储：共享volumes K8S引入数据卷概念，使用数据卷进行持久化存储, Pod中的多个容器可以公用同一个卷进行读写, 不同Node里面的Pod也可以共用卷。 共享存储 yaml例子，Pod1中创建了两个容器app1和app2，两个容器共享data卷和网络\napiVersion: v1 kind: Pod metadata: name: Pod1 spec: containers: - name: app1 image: centos command: [\u0026#34;./app1\u0026#34;] volumeMounts: - name: data mountPath: /data - name: app2 image: centos command: [\u0026#34;./app2\u0026#34;] volumeMounts: - name: data mountPath: /data volumns: - name: data emptyDir: {} Service 在 Kubernetes（通常简称为K8s）中，Pod 是有生命周期的，它们可以被创建和销毁，一旦被销毁生命就永远结束。通过ReplicationController 能够动态地创建和销毁 Pod，但 Pod 的 IP 地址不是稳定可依赖的。若其他应用依赖该 Pod，Pod 被删除重建后，因为 IP 变化的缘故其他应用无法访问该 Pod 上的服务。Service 是一种抽象，用于定义一组 Pod 的访问方式。Service 提供了一种稳定的网络终结点，使得其他应用或服务能够通过该终结点访问到一组运行在集群中的 Pod。\nService 允许其他应用或服务通过 Service 名称而不是具体的 Pod IP 地址来访问后端服务。这样，当 Pod 的 IP 地址发生变化时，不会影响其他服务的访问，因为它们只需要知道 Service 的名字。总体而言，Service 是 Kubernetes 中非常重要的概念，它提供了一种抽象层，简化了对底层 Pod 的访问和管理，使得应用和服务更容易地进行扩展和维护。\nkind: Service # 资源类型 apiVersion: v1 # 资源版本 metadata: # 元数据 name: service # 资源名称 namespace: dev # 命名空间 spec: # 描述 selector: # 标签选择器，用于确定当前service代理哪些pod app: nginx type: # Service类型，指定service的访问方式 clusterIP: # 虚拟服务的ip地址 sessionAffinity: # session亲和性，支持ClientIP、None两个选项 ports: # 端口信息 - protocol: TCP port: 3017 # service端口 targetPort: 5003 # pod端口 nodePort: 31122 # 主机端口, 将Service通过指定的Node上的端口暴露给外部 Service类型 在Kubernetes中，Service有不同的类型，每种类型都用于不同的用例和场景。以下是Kubernetes中Service的主要类型：\nClusterIP: 这是默认的Service类型。它为Service创建一个稳定的虚拟IP地址，只能在集群内部访问。这种类型通常用于将服务暴露给集群内的其他服务或Pod。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 NodePort： 这种类型在ClusterIP的基础上，为Service在每个节点上绑定一个静态端口，使得可以通过节点的IP地址和该静态端口从集群外部访问Service。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 type: NodePort # 将Service的类型设置为NodePort，使其在每个节点上绑定一个静态端口 LoadBalancer： 这种类型在NodePort的基础上，通过云服务提供商（例如AWS、GCP、Azure）的负载均衡器创建外部可访问的IP地址。这样可以将服务公开给互联网或其他外部网络。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 type: LoadBalancer # 将Service的类型设置为LoadBalancer，通过云服务提供商创建外部可访问的IP地址 ExternalName: 这种类型允许Service通过DNS CNAME记录映射到外部服务的名称。它通常用于将Kubernetes内的服务与集群外的服务集成。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: type: ExternalName # 将Service的类型设置为ExternalName externalName: external-service.example.com # 使用外部服务的名称 参考链接 Kubernetes系列学习文章：https://cloud.tencent.com/developer/article/1443520 K8S-Pod 的概念和简介: https://blog.csdn.net/nvd11/article/details/127743141 K8S中文官方文档：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ 云原生资料库：https://jimmysong.io/kubernetes-handbook/concepts/service.html ","date":"2023-11-25T00:00:00Z","permalink":"https://tsan1024.github.io/post/tech/2023-11-25-k8s/","section":"post","tags":["k8s"],"title":"k8s学习笔记（1）"},{"categories":["Robots"],"contents":"robots ros教学 https://fishros.com/d2lros2/#/\nros1与ros2对比\n参考资料 https://getiot.tech/zh/ros2/ros2-installation-on-ubuntu\nhttps://docs.elephantrobotics.com/docs/gitbook/8-ApplicationBaseCPlus/8.4-coord.html\n","date":"2023-11-22T00:00:00Z","permalink":"https://tsan1024.github.io/post/robots/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%85%A5%E9%97%A8/","section":"post","tags":["robots"],"title":"robots 入门"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/about/","section":"","tags":null,"title":""},{"categories":null,"contents":" ","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/notes/","section":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/search/placeholder/","section":"search","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/archive/","section":"","tags":null,"title":"Posts Archive"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/search/","section":"","tags":null,"title":"Search Results"}]