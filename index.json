[{"categories":["Tech"],"contents":"testing\n","date":"2024-10-28T23:22:27+08:00","permalink":"https://tsan1024.github.io/post/ai/test/","section":"post","tags":["tag1","tag2"],"title":"An Example Post"},{"categories":["Tech"],"contents":"分类 管道（Pipes）\n命名管道（Named Pipes）：适用于无关进程之间的通信。命名管道有一个名称，可以在文件系统中进行标识。 无名管道（Unnamed Pipes）：通常用于父子进程之间的通信，因为它们在创建时不具备名称。 消息队列（Message Queues） 提供了一种通过消息发送和接收来进行进程间通信的方法。消息队列允许进程以一种异步方式传递数据。\n共享内存（Shared Memory） 允许多个进程共享一个内存段，从而实现最快速的进程通信。需要同步机制（如信号量）来避免数据竞争。\n信号（Signals） 主要用于通知进程某个事件的发生，可以用来处理简单的通知和中断。\n信号量（Semaphores） 通常用于控制对共享资源的访问。信号量可以是计数信号量，也可以是二元信号量（即互斥锁）。\n套接字（Sockets） 虽然通常用于网络通信，但也可以用于同一主机上不同进程之间的通信。套接字支持多种通信协议（如TCP和UDP）。\n内存映射文件（Memory-Mapped Files）\n通过将文件映射到内存地址空间，实现文件内容的共享，进而实现进程间通信。\n示例 管道 无名管道\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int pipefd[2]; pid_t pid; char buffer[20]; if (pipe(pipefd) == -1) { perror(\u0026#34;pipe\u0026#34;); exit(EXIT_FAILURE); } pid = fork(); if (pid == -1) { perror(\u0026#34;fork\u0026#34;); exit(EXIT_FAILURE); } if (pid == 0) { // 子进程 std::cout \u0026lt;\u0026lt; \u0026#34;child: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; close(pipefd[1]); // 关闭写端 read(pipefd[0], buffer, sizeof(buffer)); std::cout \u0026lt;\u0026lt; \u0026#34;Child received: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; std::endl; close(pipefd[0]); } else { // 父进程 std::cout \u0026lt;\u0026lt; \u0026#34;father: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; close(pipefd[0]); // 关闭读端 write(pipefd[1], \u0026#34;Hello, world!\u0026#34;, 14); close(pipefd[1]); wait(NULL); // 等待子进程结束 } return 0; } 有名管道\nwrite.cpp // writer.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { const char *fifo_path = \u0026#34;/tmp/my_fifo\u0026#34;; // 创建命名管道（如果已经存在则不会重新创建）mkfifo create fifo // if (mkfifo(fifo_path, 0666) == -1) { // perror(\u0026#34;mkfifo\u0026#34;); // return 1; // } // 打开命名管道 int fd = open(fifo_path, O_WRONLY); if (fd == -1) { perror(\u0026#34;open\u0026#34;); return 1; } // 写入消息到管道 const char *message = \u0026#34;Hello from writer!\u0026#34;; if (write(fd, message, strlen(message) + 1) == -1) { perror(\u0026#34;write\u0026#34;); close(fd); return 1; } // 关闭管道 close(fd); return 0; } read.cpp // reader.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { const char *fifo_path = \u0026#34;/tmp/my_fifo\u0026#34;; // 创建命名管道（如果已经存在则不会重新创建） if (mkfifo(fifo_path, 0666) == -1) { perror(\u0026#34;mkfifo\u0026#34;); return 1; } // 打开命名管道 int fd = open(fifo_path, O_RDONLY); if (fd == -1) { perror(\u0026#34;open\u0026#34;); return 1; } // 从管道读取消息 char buffer[128]; if (read(fd, buffer, sizeof(buffer)) == -1) { perror(\u0026#34;read\u0026#34;); close(fd); return 1; } // 输出读取的消息 std::cout \u0026lt;\u0026lt; \u0026#34;Reader received: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; std::endl; // 关闭管道 close(fd); return 0; } 消息队列 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/ipc.h\u0026gt; #include\u0026lt;sys/msg.h\u0026gt; #define KEY 0x9999 typedef struct{ long msgType; char data[80]; }Msg; // Msg可以随意定义但需要含有一个消息类型type，而且还必须是结构体的第一个成员。而结构体中的其他成员都被认为是要发送的消息体数据。 int main(void){ pid_t pid; int msgid; int i = 0; int ret; Msg msg; pid = fork(); if(pid == 0){ msgid = msgget(KEY, IPC_CREAT | 0666); if(msgid == -1){ perror(\u0026#34;\u0026#34;); return -1; } while(1){ msg.msgType = 1; sprintf(msg.data, \u0026#34;Hello I am sender %d\u0026#34;, i); msgsnd(msgid, \u0026amp;msg, sizeof(Msg) - sizeof(long), 0); i++; sleep(1); } }else if(pid \u0026gt; 0){ msgid = msgget(KEY, IPC_CREAT | 0666); if(msgid == -1){ perror(\u0026#34;\u0026#34;); return -1; } while(1){ ret = msgrcv(msgid, \u0026amp;msg, sizeof(Msg) - sizeof(long), 1, 0); if(ret \u0026lt; 0){ perror(\u0026#34;\u0026#34;); return -1; } printf(\u0026#34;Father RCV :%s\\n\u0026#34;, msg.data); } }else{ perror(\u0026#34;\u0026#34;); return -1; } return 0; } 共享进程 进程a\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #define SHM_SIZE 1024 int main() { int shmid; char *shmaddr; // 创建共享内存段 shmid = shmget(IPC_PRIVATE, SHM_SIZE, IPC_CREAT | 0666); if (shmid == -1) { perror(\u0026#34;shmget\u0026#34;); return 1; } // 将共享内存段连接到当前进程的地址空间 shmaddr = static_cast\u0026lt;char*\u0026gt;(shmat(shmid, nullptr, 0)); if (shmaddr == (char*)-1) { perror(\u0026#34;shmat\u0026#34;); return 1; } // 写入数据到共享内存 strncpy(shmaddr, \u0026#34;Hello from parent process\u0026#34;, SHM_SIZE); // 分离共享内存，分离后当前进程则无法再修改该共享内存段 shmdt(shmaddr); // strncpy(shmaddr, \u0026#34;Updated message\u0026#34;, strlen(\u0026#34;Updated message\u0026#34;) + 1); // 打印共享内存ID以便子进程使用 std::cout \u0026lt;\u0026lt; \u0026#34;Shared memory ID: \u0026#34; \u0026lt;\u0026lt; shmid \u0026lt;\u0026lt; std::endl; return 0; } 进程b\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #define SHM_SIZE 1024 int main(int argc, char* argv[]) { int shmid; char *shmaddr; if (argc != 2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;shared_memory_id\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 获取共享内存ID shmid = std::stoi(argv[1]); // 连接到共享内存 shmaddr = static_cast\u0026lt;char*\u0026gt;(shmat(shmid, nullptr, 0)); if (shmaddr == (char*)-1) { perror(\u0026#34;shmat\u0026#34;); return 1; } // 从共享内存中读取数据并打印 std::cout \u0026lt;\u0026lt; \u0026#34;Message from parent process: \u0026#34; \u0026lt;\u0026lt; shmaddr \u0026lt;\u0026lt; std::endl; // 更新共享内存 strncpy(shmaddr, \u0026#34;Updated message\u0026#34;, strlen(\u0026#34;Updated message\u0026#34;) + 1); // 分离共享内存 shmdt(shmaddr); return 0; } 信号 进程间通过信号通信\n// receiver.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 信号处理程序 void handle_sigusr1(int sig) { std::cout \u0026lt;\u0026lt; \u0026#34;Received SIGUSR1 signal. \u0026#34; \u0026lt;\u0026lt; sig \u0026lt;\u0026lt; std::endl; } int main() { // 设置信号处理程序 if (signal(SIGUSR1, handle_sigusr1) == SIG_ERR) { perror(\u0026#34;Error setting signal handler\u0026#34;); return 1; } // 使进程保持运行，以等待信号 while (true) { std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for signal...\u0026#34; \u0026lt;\u0026lt; std::endl; sleep(5); } return 0; } // sender.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid_t pid; std::cout \u0026lt;\u0026lt; \u0026#34;Enter PID of the process to send SIGUSR1: \u0026#34;; std::cin \u0026gt;\u0026gt; pid; // 发送 SIGUSR1 信号 if (kill(pid, SIGUSR1) == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Signal sent successfully.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { perror(\u0026#34;Error sending signal\u0026#34;); } return 0; } 信号量 // writer.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; const char* SHM_NAME = \u0026#34;/shared_memory\u0026#34;; const char* SEM_NAME = \u0026#34;/semaphore\u0026#34;; struct SharedData { char message[256]; }; int main() { int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666); ftruncate(shm_fd, sizeof(SharedData)); SharedData* shared_data = (SharedData*)mmap(0, sizeof(SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); sem_t* sem = sem_open(SEM_NAME, O_CREAT, 0666, 1); sem_wait(sem); // Wait for semaphore std::strcpy(shared_data-\u0026gt;message, \u0026#34;Hello from writer!\u0026#34;); sem_post(sem); // Signal semaphore munmap(shared_data, sizeof(SharedData)); close(shm_fd); sem_close(sem); return 0; } // reader.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; const char* SHM_NAME = \u0026#34;/shared_memory\u0026#34;; const char* SEM_NAME = \u0026#34;/semaphore\u0026#34;; struct SharedData { char message[256]; }; int main() { int shm_fd = shm_open(SHM_NAME, O_RDWR, 0666); SharedData* shared_data = (SharedData*)mmap(0, sizeof(SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); sem_t* sem = sem_open(SEM_NAME, 0); sem_wait(sem); // Wait for semaphore std::cout \u0026lt;\u0026lt; \u0026#34;Message from writer: \u0026#34; \u0026lt;\u0026lt; shared_data-\u0026gt;message \u0026lt;\u0026lt; std::endl; sem_post(sem); // Signal semaphore munmap(shared_data, sizeof(SharedData)); close(shm_fd); sem_close(sem); return 0; } ","date":"2024-05-30T16:38:45+08:00","permalink":"https://tsan1024.github.io/post/tech/c++%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","section":"post","tags":["c++"],"title":"C++进程间通信"},{"categories":["Tech"],"contents":"c/c++类型转换种分为两种：隐式类型转换（编译器）、显示类型转换（强制类型转换）\nc 类型转换 c语言的类型转换主要有两种：\n(new-type) expression new-type (expression) 局限性 转换随意，eg: 指向const对象的指针可随意换成指向非const对象的指针，指向基类对象的指针转换成指向派生类对象的指针。 缺乏关键字与标识符，不易代码排查 c++ 强制类型转换 static_cast: dynamic_cast const_cast reinterpret_cast 用法 强制类型转换运算符\u0026lt;目标类型\u0026gt;（待转换表达式）\nstatic_cast 基本类型转换，例如 int 转换为 float。（向上转换） 类层次结构中上行转换（从派生类到基类，安全）。 类层次结构中下行转换（从基类到派生类，但不检查安全性，不安全不建议使用）。 // 上行转换，派生类→基类 Derive* d = new Derive(); Base* b = static_cast\u0026lt;Base*\u0026gt;(d); // 下行转换，基类→派生类 Base* b = new Base(); Derive* d = static_cast\u0026lt;Derive*\u0026gt;(b); 移除指针的 const/volatile 修饰符（但不添加）。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换成void类型。 示例：\nint a = 10; double b = static_cast\u0026lt;double\u0026gt;(n); int* d = \u0026amp;a; void* c = static_cast\u0026lt;void*\u0026gt;(d); //任意类型转换成void类型 Base* basePtr = new Derived(); Derived* derivedPtr = static_cast\u0026lt;Derived*\u0026gt;(basePtr); 不可使用\n不同类型的指针之间互相转换 不同类型的引用之间的转换 整型和指针之间转换 优点\n编译时转换，性能高。 可读性强，语法清晰。\n缺点\n无法进行运行时类型检查，可能导致不安全的类型转换\ndynastic_cast 只有在派生类之间转换时才使用dynamic_cast，type必须是类指针，类引用或者void*。\n基类必须要有虚函数，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表（如果一个类没有虚函数，那么一般意义上，这个类的设计者也不想它成为一个基类）。\n对于下行转换，dynamic_cast是安全的（当类型不一致时，转换过来的是空指针），而static_cast是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题）\nBase* basePtr = new Derived(); Derived* derivedPtr = dynamic_cast\u0026lt;Derived*\u0026gt;(basePtr); if (derivedPtr) { // 转换成功，可以安全使用 derivedPtr } else { // 转换失败，处理错误情况 } class BaseClass { public: int m_iNum; virtual void foo(){};//基类必须有虚函数。保持多台特性才能使用dynamic_cast }; class DerivedClass: public BaseClass { public: char *m_szName[100]; void bar(){}; }; BaseClass* pb = new DerivedClass(); DerivedClass *pd1 = static_cast\u0026lt;DerivedClass *\u0026gt;(pb);//子类-\u0026gt;父类，静态类型转换，正确但不推荐 DerivedClass *pd2 = dynamic_cast\u0026lt;DerivedClass *\u0026gt;(pb);//子类-\u0026gt;父类，动态类型转换，正确 BaseClass* pb2 = new BaseClass(); //父类-\u0026gt;子类，静态类型转换，危险！访问子类m_szName成员越界 DerivedClass *pd21 = static_cast\u0026lt;DerivedClass *\u0026gt;(pb2); //父类-\u0026gt;子类，动态类型转换，安全的。结果是NULL DerivedClass *pd22 = dynamic_cast\u0026lt;DerivedClass *\u0026gt;(pb2); 优点\n运行时类型检查，保证转换的安全性。 尤其适用于多态环境。\n缺点\n运行时开销较高。 需要启用 RTTI（运行时类型信息），增加了程序的复杂性。\nconst_cast 用途(去除常量行为较危险)\n添加或移除 const/volatile 修饰符。 常用于需要修改本应不可变的数据时，例如第三方库的 API 不接受 const 数据。 常量指针转换为非常量指针，并且仍然指向原来的对象 常量引用被转换为非常量引用，并且仍然指向原来的对象 struct SA { int i; }; const SA ra; //ra.i = 10; //直接修改const类型，编译错误 SA \u0026amp;rb = const_cast\u0026lt;SA\u0026amp;\u0026gt;(ra); rb.i = 10; const int* constPtr = \u0026amp;i; int* modifiablePtr = const_cast\u0026lt;int*\u0026gt;(constPtr); 优点\n允许在非常特殊的场景下修改常量数据。\n缺点\n可能导致未定义行为，如果用于去除真正的常量属性。 易引入错误，应谨慎使用。 reinterpret_cast（尽量不使用） 用途\n强制转换指针类型，几乎可以在任何指针类型之间转换。 用于实现底层操作，例如位操作、系统调用、硬件编程等。 int* intPtr = new int(10); char* charPtr = reinterpret_cast\u0026lt;char*\u0026gt;(intPtr); 优点\n提供极大的灵活性，可以进行几乎任意的类型转换。 缺点\n极易引入不安全的代码，可能导致未定义行为。 可读性差，难以维护和调试。 总结\nstatic_cast 适用于大多数类型安全的显式转换，效率高。 dynamic_cast 适用于需要运行时类型检查的多态环境，确保类型安全。 const_cast 用于移除或添加常量属性，适用于特定场景。 reinterpret_cast 适用于底层操作，但容易引发错误，应谨慎使用。 引用 https://blog.csdn.net/chen134225/article/details/81305049 ","date":"2024-05-23T09:38:45+08:00","permalink":"https://tsan1024.github.io/post/tech/c++%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","section":"post","tags":["c++"],"title":"C++强制类型转换"},{"categories":["Tech"],"contents":"分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识\nhttps://cloud.tencent.com/developer/article/1419513\n","date":"2024-05-10T16:38:45+08:00","permalink":"https://tsan1024.github.io/post/tech/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/","section":"post","tags":["分布式"],"title":"分布式"},{"categories":["Tech"],"contents":"https://blog.csdn.net/cywosp/article/details/38965239\nhttps://www.cnblogs.com/cscshi/p/15705033.html\nhttps://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/\nhttps://zhuanlan.zhihu.com/p/143430585\nhttps://xiehongfeng100.github.io/2018/09/08/net-read-and-write/\n","date":"2024-05-09T14:53:59+08:00","permalink":"https://tsan1024.github.io/post/tech/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/","section":"post","tags":["linux","socket"],"title":"文件描述符"},{"categories":["Tech"],"contents":"valgrind perf gporf 1 perf Perf是内置于Linux内核源码树中的性能剖析工具。以性能事件为基础，常用于性能瓶颈的查找与热点代码的定位。\n1.1 使用 常见有两种使用方式：\n直接使用perf启动二进制服务，有一个 perf record -e cpu-clock -g ./start 挂载到已启动的进程上 2 Gprof gprof用于监控程序中每个方法的执行时间和被调用次数，方便找出程序中最耗时的函数。在程序正常退出后，会生成gmon.out文件，解析这个文件，可以生成一个可视化的报告\nhttps://zhuanlan.zhihu.com/p/34629489\n","date":"2024-05-08T14:53:59+08:00","permalink":"https://tsan1024.github.io/post/tech/c++-tools/","section":"post","tags":["c++","工具"],"title":"常见的c++性能调优工具"},{"categories":["Tech"],"contents":"多线程操作,\n","date":"2024-05-07T16:38:45+08:00","permalink":"https://tsan1024.github.io/post/tech/c++/","section":"post","tags":["c++"],"title":"C++并发编程总结"},{"categories":["Tech"],"contents":"引言 创见型模式 工厂方法模式 抽象工厂模式 生成器模式 原型模式 单例模式 结构型模式 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式 行为模式 责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模版方法模式 访问者模式 简单工厂模式，工厂模式，抽象工厂模式 简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。 工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。 抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。\nsimple factory # 简单工厂 package factory import \u0026#34;fmt\u0026#34; type Product interface { Show(name string) } type ProductA struct { Name string } type ProductB struct { Name string } func (p *ProductA) Show(name string) { fmt.Println(\u0026#34;ProductA \u0026#34;, p.Name) } func (p *ProductB) Show(name string) { fmt.Println(\u0026#34;ProductB \u0026#34;, p.Name) } type Factory struct { } func (f Factory) NewSimpleFactory(t string) Product { switch t { case \u0026#34;A\u0026#34;: return \u0026amp;ProductA{Name: t} case \u0026#34;B\u0026#34;: return \u0026amp;ProductB{Name: t} } return nil } # 简单工厂测试 package factory import ( \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) func TestNewSimpleFactory(t *testing.T) { type args struct { t string } tests := []struct { name string args args want Product }{ { name: \u0026#34;A\u0026#34;, args: args{t: \u0026#34;A\u0026#34;}, want: \u0026amp;ProductA{Name: \u0026#34;A\u0026#34;}, }, { name: \u0026#34;B\u0026#34;, args: args{t: \u0026#34;B\u0026#34;}, want: \u0026amp;ProductB{Name: \u0026#34;B\u0026#34;}, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { f := Factory{} if got := f.NewSimpleFactory(tt.args.t); !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;NewFactory() = %v, want %v\u0026#34;, got, tt.want) } }) } } ## c++ implement #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Product { public: Product(std::string name): Name(name){} std::string GetName() { return this-\u0026gt;Name; } virtual void Show(const std::string\u0026amp; name) = 0; private: std::string Name; }; class ProductA : public Product { public: using Product::Product; void Show(const std::string\u0026amp; name) override { std::cout \u0026lt;\u0026lt; \u0026#34;ProductA \u0026#34; \u0026lt;\u0026lt; GetName() \u0026lt;\u0026lt; std::endl; } }; class ProductB : public Product { public: using Product::Product; void Show(const std::string\u0026amp; name) override { std::cout \u0026lt;\u0026lt; \u0026#34;ProductB \u0026#34; \u0026lt;\u0026lt; GetName() \u0026lt;\u0026lt; std::endl; } }; class SimpleFactory { public: Product* NewSimpleProduct(const std::string\u0026amp; t) { if (t == \u0026#34;A\u0026#34;) { return new ProductA(t); } else if (t == \u0026#34;B\u0026#34;) { return new ProductB(t); } return nullptr; } }; int main() { SimpleFactory factory; Product* productA = factory.NewSimpleProduct(\u0026#34;A\u0026#34;); if (productA) { productA-\u0026gt;Show(\u0026#34;A\u0026#34;); delete productA; } Product* productB = factory.NewSimpleProduct(\u0026#34;B\u0026#34;); if (productB) { productB-\u0026gt;Show(\u0026#34;B\u0026#34;); delete productB; } return 0; } factory pattern #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // Product interface class Product { public: virtual void Show() const = 0; virtual ~Product() = default; }; // ProductA class class ProductA : public Product { public: void Show() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ProductA\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // ProductB class class ProductB : public Product { public: void Show() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteProductB\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Factory interface class Factory { public: virtual Product* CreateProduct() const = 0; virtual ~Factory() = default; }; // FactoryA class class FactoryA : public Factory { public: Product* CreateProduct() const override { return new ProductA(); } }; // FactoryB class class FactoryB : public Factory { public: Product* CreateProduct() const override { return new ProductB(); } }; int main() { // Create FactoryA Factory* factoryA = new FactoryA(); Product* productA = factoryA-\u0026gt;CreateProduct(); productA-\u0026gt;Show(); delete productA; delete factoryA; // Create FactoryB Factory* factoryB = new FactoryB(); Product* productB = factoryB-\u0026gt;CreateProduct(); productB-\u0026gt;Show(); delete productB; delete factoryB; return 0; } 抽象工厂 # include \u0026lt;iostream\u0026gt; class AbstractProductA { public: virtual void ShowA() const = 0; virtual ~AbstractProductA() = default; }; class AbstractProductB { public: virtual void ShowB() const = 0; virtual ~AbstractProductB() = default; }; class ProductA1 : public AbstractProductA { public: void ShowA() const override{ std::cout \u0026lt;\u0026lt; \u0026#34;Product A\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class ProductB1 : public AbstractProductB { public: void ShowB() const override{ std::cout \u0026lt;\u0026lt; \u0026#34;Product B\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class AbstractFactory { public: virtual AbstractProductA* CreateProductA() const = 0; virtual AbstractProductB* CreateProductB() const = 0; virtual ~AbstractFactory() = default; }; class AbstractFactory1 : public AbstractFactory { public: AbstractProductA* CreateProductA() const override { return new ProductA1(); } AbstractProductB* CreateProductB() const override { return new ProductB1(); } }; int main() { AbstractFactory *factory = new AbstractFactory1(); AbstractProductA* Product1 = factory-\u0026gt;CreateProductA(); AbstractProductB* Product2 = factory-\u0026gt;CreateProductB(); Product1-\u0026gt;ShowA(); Product2-\u0026gt;ShowB(); delete Product1; delete Product2; delete factory; return 0; } 参考资料\nhttps://lailin.xyz/post/go-design-pattern.html https://refactoringguru.cn/design-patterns ","date":"2023-12-27T23:40:25+08:00","permalink":"https://tsan1024.github.io/post/tech/design-pattern/","section":"post","tags":["design-pattern","golang"],"title":"设计模式"},{"categories":["Tech"],"contents":"go Test 单元测试编写 Go 语言的单元测试默认采用官方自带的测试框架，通过引入 testing 包以及 执行 go test 命令来实现单元测试功能。\nGo 单元测试的基本规范如下：\n测试函数需导入 testing 包。测试函数的命名类似func TestName(t *testing.T)，入参是 *testing.T 测试函数的函数名须以大写的 Test 开头，后面紧跟的函数名，比如 func TestName(t *testing.T) 或者 func Test_name(t *testing.T)， 但是 func Testname(t *testing.T)不会被检测到 一般测试文件的命名，都是 {source_filename}_test.go，比如源代码文件是Add.go ，那么就会在 Add.go 的相同目录下，再建立一个 Add_test.go 的单元测试文件 go test 会遍历所有的 *_test.go 中符合上述命名规则的函数，然后生成一个临时的 main 包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n基础示例 # 原函数 package test func Add(args1, args2 int) int { result := args1 + args2 return result } # 测试代码 package test import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestAdd(t *testing.T) { value := Add(1, 2) fmt.Println(value) } # 运行所有test go test # 运行test并打印详情 go test -v # 运行具体某个方法的单元测试 # go test -v -run=\u0026#34;xxx\u0026#34; # 执行单测并计算覆盖率 go test -v -cover # 将覆盖率导入到文件 go test -cover -covermode=count -coverprofile=cover.out # covermode 代码分析模式（set：是否执行；count：执行次数；atomic：次数，并发执行） # 查看测试文件 go tool cover -func=cover.out 子测试（Subtests） func TestReduce(t *testing.T) { t.Run(\u0026#34;add\u0026#34;, func(t *testing.T) { if Reduce(2, 3) == 4 { t.Fatal(\u0026#34;fail\u0026#34;) } }) t.Run(\u0026#34;neg\u0026#34;, func(t *testing.T) { if Reduce(2, 3) != -6 { t.Fatal(\u0026#34;fail\u0026#34;) } }) } 对于多个子测试的场景，推荐表格驱动测试(table-driven tests)的写法： func TestReduce(t *testing.T) { cases := []struct { Name string A, B, Expected int }{ {\u0026#34;pos\u0026#34;, 2, 3, 6}, {\u0026#34;neg\u0026#34;, 2, -3, -6}, {\u0026#34;zero\u0026#34;, 2, 0, 0}, } for _, c := range cases { t.Run(c.Name, func(t *testing.T) { if ans := Add(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026#34;%d * %d expected %d, but %d got\u0026#34;, c.A, c.B, c.Expected, ans) } }) } } 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的优势如下：\n新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。 如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。\n帮助函数(helpers) 对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。\ntype addCase struct{ A, B, Expected int } func createAddTestCase(t *testing.T, c *addCase) { t.Helper() if ans := Add(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026#34;%d * %d expected %d, but %d got\u0026#34;, c.A, c.B, c.Expected, ans) } } func TestAdd(t *testing.T) { createAddTestCase(t, \u0026amp;addCase{4, 2, 6}) // success case createAddTestCase(t, \u0026amp;addCase{1, -3, -6}) // wrong case } 为方便定位，调用 t.Helper() 可以让报错信息更准确，直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。\nsetup 与 teardown package codetest import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) // setup 函数，在所有测试运行之前执行 func setup() { fmt.Println(\u0026#34;Setup before tests\u0026#34;) // 执行一些初始化操作 } // teardown 函数，在所有测试运行之后执行 func teardown() { fmt.Println(\u0026#34;Teardown after tests\u0026#34;) // 执行一些清理操作 } // TestMain 函数，用于自定义测试的行为 func TestMain(m *testing.M) { // 执行 setup 函数 setup() // 运行所有测试 exitCode := m.Run() // 执行 teardown 函数 teardown() // 退出测试程序 fmt.Println(\u0026#34;Exiting with code\u0026#34;, exitCode) } // 具体的测试函数 func TestSomething(t *testing.T) { // 在这里编写你的测试逻辑 fmt.Println(\u0026#34;Running TestSomething\u0026#34;) // 断言或其他测试操作 } func TestAnotherThing(t *testing.T) { // 在这里编写另一个测试逻辑 fmt.Println(\u0026#34;Running TestAnotherThing\u0026#34;) // 断言或其他测试操作 } func setupTest(tb testing.TB) func(tb testing.TB) { fmt.Printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, \u0026#34;\u0026gt;\u0026gt; Setup Test\\n\u0026#34;) return func(tb testing.TB) { fmt.Printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, \u0026#34;\u0026gt;\u0026gt; Teardown Test\\n\u0026#34;) } } func TestToString(t *testing.T) { type args struct { value interface{} } tests := []struct { name string args args want interface{} }{ { name: \u0026#34;int\u0026#34;, args: args{ value: 101, }, want: \u0026#34;100\u0026#34;, }, { name: \u0026#34;boolean\u0026#34;, args: args{ value: true, }, want: \u0026#34;true\u0026#34;, }, { name: \u0026#34;float32\u0026#34;, args: args{ value: float32(100.01), }, want: \u0026#34;100.01\u0026#34;, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { teardown := setupTest(t) defer teardown(t) if got := ToString(tt.args.value); !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;ToString() = %v, want %v\u0026#34;, got, tt.want) } }) } } // ToString convert any type to string func ToString(value interface{}) string { if v, ok := value.(*string); ok { return *v } return fmt.Sprintf(\u0026#34;%v\u0026#34;, value) } 测试网络 需要测试某个 API 接口的 handler 能够正常工作，例如 addHandler\npackage codetest // test code import ( \u0026#34;bytes\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; ) func addHandler(w http.ResponseWriter, r *http.Request) { body, _ := io.ReadAll(r.Body) w.Write([]byte(body)) } func handleError(t *testing.T, err error) { t.Helper() if err != nil { t.Fatal(\u0026#34;failed\u0026#34;, err) } } func TestConn(t *testing.T) { ln, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:0\u0026#34;) handleError(t, err) defer ln.Close() payload := []byte(`{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}`) // 创建一个字节缓冲区，并将数据写入其中 reqBody := bytes.NewBuffer(payload) http.HandleFunc(\u0026#34;/add\u0026#34;, addHandler) go http.Serve(ln, nil) resp, err := http.Post(\u0026#34;http://\u0026#34;+ln.Addr().String()+\u0026#34;/add\u0026#34;, \u0026#34;application/json\u0026#34;, reqBody) handleError(t, err) defer resp.Body.Close() body, err := io.ReadAll(resp.Body) handleError(t, err) if string(body) != \u0026#34;add\u0026#34; { t.Fatal(\u0026#34;expected add, but got\u0026#34;, string(body)) } } 针对 http 开发的场景，更推荐使用标准库 net/http/httptest 进行测试。使用 httptest 模拟请求对象(req)和响应对象(w)，将TestConn替换成如下:\nfunc TestConn(t *testing.T) { req := httptest.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://example.com/add\u0026#34;, nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != \u0026#34;add\u0026#34; { t.Fatal(\u0026#34;expected add, but got\u0026#34;, string(bytes)) } } Benchmark 基准测试 基准测试用例的定义如下：\nfunc BenchmarkName(b *testing.B){ // ... } 函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。\n执行如下：\ngo test -benchmem -bench . 以下参考极客兔兔，基准测试报告每一列值对应的含义如下：\ntype BenchmarkResult struct { N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 } 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：\nfunc BenchmarkHello(b *testing.B) { ... // 耗时操作, 如 big := NewBig() b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026#34;hello\u0026#34;) } } 使用 RunParallel 测试并发性能\nfunc BenchmarkParallel(b *testing.B) { templ := template.Must(template.New(\u0026#34;test\u0026#34;).Parse(\u0026#34;Hello, {{.}}!\u0026#34;)) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(\u0026amp;buf, \u0026#34;World\u0026#34;) } }) } 执行\ngo test -benchmem -bench . 参考连接： https://juejin.cn/post/7172037988950474759 https://brantou.github.io/2017/05/24/go-cover-story/ https://ruichengm1987.github.io/docs/go/ https://pkg.go.dev/testing ","date":"2023-12-26T23:17:45+08:00","permalink":"https://tsan1024.github.io/post/tech/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/","section":"post","tags":["golang","test"],"title":"golang 单元测试"},{"categories":["Tech"],"contents":"c++编程规范： https://zh-google-styleguide.readthedocs.io/en/latest/contents/\n","date":"2023-12-08T23:01:12+08:00","permalink":"https://tsan1024.github.io/post/tech/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","section":"post","tags":["c++"],"title":"编程规范"},{"categories":["robots"],"contents":"ROS2通信模型 话题 服务 参数 动作 参考链接 入门教程：https://book.guyuehome.com/ ROS 和 ROS2 架构和通信 https://codeantenna.com/a/909CWGyaSo#5_ROS_2__131 ","date":"2023-12-03T21:02:15+08:00","permalink":"https://tsan1024.github.io/post/robots/ros%E9%80%9A%E4%BF%A1/","section":"post","tags":["ros2","ros"],"title":"ROS架构与通信"},{"categories":["Robots"],"contents":"机器人学导论 \u003c!DOCTYPE HTML\u003e 参考链接： Hugo 通过 ShortCodes 添加视频\n","date":"2023-11-28T23:42:23+08:00","permalink":"https://tsan1024.github.io/post/robots/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91/","section":"post","tags":["robots"],"title":"机器人导学教学视频"},{"categories":["Tech"],"contents":"k8s 架构 MasterNode包含3个程序，分别是： ApiServer： 提供HTTP Rest接口，是集群中各种核心资源的CRUD的统一入口，是集群中各个组件交互的核心枢纽 集群资源配额的统一入口 提供了完备的集群安全机制 ControllerManager： 实时监控集群中如Service等各种资源的状态变化，不断尝试将它们的副本数量维持在一个期望的状态。 Scheduler： 负责调度功能，如：为Pod找到一个合适的宿主机器 WorkerNode包含两个组件， 分别是： kubelet Node节点管理 Pod管理，同容器运行时交互下发容器的创建/关闭命令 容器健康状态检查 kube-proxy 通过为Service资源的ClusterIP生成iptable或ipvs规则，实现将K8S内部的服务暴露到集群外面去 概念 Pod Pod 是一组紧密关联的容器集合，它们共享 IPC 和 Network namespace，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod的实现基于共享网络和共享存储：\n共享网络：共享IP、Ports及MAC地址\n在POD的初始化中，会首先建立1个叫做Pause或info根容器。在这个根容器中，会被分配1个ip地址，mac地址和 ports端口。POD会继续根据要求创造若干个应用容器，每个应用容器都会作为子容器加入到根容器中，这些子容器就可以共享根容器的网络资源。 共享网络 共享存储：共享volumes K8S引入数据卷概念，使用数据卷进行持久化存储, Pod中的多个容器可以公用同一个卷进行读写, 不同Node里面的Pod也可以共用卷。 共享存储 yaml例子，Pod1中创建了两个容器app1和app2，两个容器共享data卷和网络\napiVersion: v1 kind: Pod metadata: name: Pod1 spec: containers: - name: app1 image: centos command: [\u0026#34;./app1\u0026#34;] volumeMounts: - name: data mountPath: /data - name: app2 image: centos command: [\u0026#34;./app2\u0026#34;] volumeMounts: - name: data mountPath: /data volumns: - name: data emptyDir: {} Service 在 Kubernetes（通常简称为K8s）中，Pod 是有生命周期的，它们可以被创建和销毁，一旦被销毁生命就永远结束。通过ReplicationController 能够动态地创建和销毁 Pod，但 Pod 的 IP 地址不是稳定可依赖的。若其他应用依赖该 Pod，Pod 被删除重建后，因为 IP 变化的缘故其他应用无法访问该 Pod 上的服务。Service 是一种抽象，用于定义一组 Pod 的访问方式。Service 提供了一种稳定的网络终结点，使得其他应用或服务能够通过该终结点访问到一组运行在集群中的 Pod。\nService 允许其他应用或服务通过 Service 名称而不是具体的 Pod IP 地址来访问后端服务。这样，当 Pod 的 IP 地址发生变化时，不会影响其他服务的访问，因为它们只需要知道 Service 的名字。总体而言，Service 是 Kubernetes 中非常重要的概念，它提供了一种抽象层，简化了对底层 Pod 的访问和管理，使得应用和服务更容易地进行扩展和维护。\nkind: Service # 资源类型 apiVersion: v1 # 资源版本 metadata: # 元数据 name: service # 资源名称 namespace: dev # 命名空间 spec: # 描述 selector: # 标签选择器，用于确定当前service代理哪些pod app: nginx type: # Service类型，指定service的访问方式 clusterIP: # 虚拟服务的ip地址 sessionAffinity: # session亲和性，支持ClientIP、None两个选项 ports: # 端口信息 - protocol: TCP port: 3017 # service端口 targetPort: 5003 # pod端口 nodePort: 31122 # 主机端口, 将Service通过指定的Node上的端口暴露给外部 Service类型 在Kubernetes中，Service有不同的类型，每种类型都用于不同的用例和场景。以下是Kubernetes中Service的主要类型：\nClusterIP: 这是默认的Service类型。它为Service创建一个稳定的虚拟IP地址，只能在集群内部访问。这种类型通常用于将服务暴露给集群内的其他服务或Pod。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 NodePort： 这种类型在ClusterIP的基础上，为Service在每个节点上绑定一个静态端口，使得可以通过节点的IP地址和该静态端口从集群外部访问Service。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 type: NodePort # 将Service的类型设置为NodePort，使其在每个节点上绑定一个静态端口 LoadBalancer： 这种类型在NodePort的基础上，通过云服务提供商（例如AWS、GCP、Azure）的负载均衡器创建外部可访问的IP地址。这样可以将服务公开给互联网或其他外部网络。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: selector: app: my-app # 选择具有标签\u0026#39;app: my-app\u0026#39;的Pod ports: - protocol: TCP port: 80 # Service的Cluster IP端口 targetPort: 8080 # 将流量转发到Pod的端口8080 type: LoadBalancer # 将Service的类型设置为LoadBalancer，通过云服务提供商创建外部可访问的IP地址 ExternalName: 这种类型允许Service通过DNS CNAME记录映射到外部服务的名称。它通常用于将Kubernetes内的服务与集群外的服务集成。\napiVersion: v1 kind: Service metadata: name: my-service # Service的名称 spec: type: ExternalName # 将Service的类型设置为ExternalName externalName: external-service.example.com # 使用外部服务的名称 参考链接 Kubernetes系列学习文章：https://cloud.tencent.com/developer/article/1443520 K8S-Pod 的概念和简介: https://blog.csdn.net/nvd11/article/details/127743141 K8S中文官方文档：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ 云原生资料库：https://jimmysong.io/kubernetes-handbook/concepts/service.html ","date":"2023-11-25T00:00:00Z","permalink":"https://tsan1024.github.io/post/tech/2023-11-25-k8s/","section":"post","tags":["k8s"],"title":"k8s学习笔记（1）"},{"categories":["Robots"],"contents":"robots ros教学 https://fishros.com/d2lros2/#/\nros1与ros2对比\n参考资料 https://getiot.tech/zh/ros2/ros2-installation-on-ubuntu\nhttps://docs.elephantrobotics.com/docs/gitbook/8-ApplicationBaseCPlus/8.4-coord.html\n","date":"2023-11-22T00:00:00Z","permalink":"https://tsan1024.github.io/post/robots/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%85%A5%E9%97%A8/","section":"post","tags":["robots"],"title":"robots 入门"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/about/","section":"","tags":null,"title":""},{"categories":null,"contents":" ","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/notes/","section":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/search/placeholder/","section":"search","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/archive/","section":"","tags":null,"title":"Posts Archive"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"0001-01-01T00:00:00Z","permalink":"https://tsan1024.github.io/search/","section":"","tags":null,"title":"Search Results"}]